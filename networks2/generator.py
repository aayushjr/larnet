import torch
import torch.nn as nn
import torch.nn.functional as F
from torch.autograd import Variable
import numpy as np
from networks2.convGRU import ConvGRUCell,ConvGRU

class upconv3d(nn.Module):
    def __init__(self, nin, nout, use_noise=True, sigma=0.2):
        super(upconv3d, self).__init__()
        self.main = nn.Sequential(
                nn.ConvTranspose3d(nin, nout, 4, 2, 1),
                nn.BatchNorm3d(nout),
                nn.ReLU(inplace=True),
                )
    def forward(self, input):
        return self.main(input)

class conv3d(nn.Module):
    def __init__(self, nin, nout, kernel_size=3, padding=1, stride=1):
        super(conv3d, self).__init__()
        self.main = nn.Sequential(
                nn.Conv3d(nin, nout, kernel_size, stride, padding),
                nn.BatchNorm3d(nout),
                nn.ReLU(inplace=True)
                )
    def forward(self, input):
        return self.main(input)

def conv3x3x3(in_planes, out_planes, stride=1):
    return nn.Conv3d(in_planes,
                     out_planes,
                     kernel_size=3,
                     stride=stride,
                     padding=1,
                     bias=False)

class Generator(nn.Module):
    """
    Class representing the Generator network to be used.
    """

    VALID_OUT_FRAMES = (16)

    def __init__(self, out_frames=16, gen_name='Video Generator'):
        """
        Initializes the Generator network.
        :param in_channels: (int) The number of channels in the input tensor.
        :param out_frames: (int) The number of frames desired in the generated output video.
                            Legal values: 8, 16
        :param gen_name: (str, optional) The name of the network (default 'Video Generator').
        Raises:
            ValueError: if 'out_frames' is not a legal value.
        """
#         if out_frames not in self.VALID_OUT_FRAMES:
#             raise ValueError('Invalid number of frames in desired output: %d' % out_frames)

        super(Generator, self).__init__()
        self.gen_name = gen_name
        self.out_frames = out_frames
        
        self.conv_gru1 = ConvGRU(input_dim=256,hidden_dim=[512],
                        kernel_size=(3,3),num_layers=1)
        self.upconv1 = upconv3d(512+256,512)
        self.conv1 = conv3d(512,256)
        

        self.conv_gru2 = ConvGRU(input_dim=256,hidden_dim=[256],
                        kernel_size=(3,3),num_layers=1)
        self.upconv2 = upconv3d(256+256,256)
        self.conv2 = conv3d(256,128)

        self.conv_gru3 = ConvGRU(input_dim=128,hidden_dim=[128],
                        kernel_size=(3,3),num_layers=1)
        self.conv3 = nn.Sequential(
                nn.Conv3d(256, 64, 3, 1, 1),
                nn.BatchNorm3d(64),
                nn.LeakyReLU(0.2,inplace=True)
                )
        self.upconv3 = nn.Sequential(
                         nn.ConvTranspose3d(128, 64, kernel_size=(1,4,4), stride=(1,2,2), padding=(0,1,1)),
                         nn.BatchNorm3d(64),
                         nn.LeakyReLU(0.2,inplace=True),
                     )
        self.conv4_a = nn.Sequential(
                nn.Conv3d(64, 8, 3, 1, 1),
                nn.BatchNorm3d(8),
                nn.LeakyReLU(0.2,inplace=True)
                )
        self.conv4_b = nn.Sequential(
                        nn.Conv3d(8,3,kernel_size=1,padding=0,stride=1,bias=True),
                        nn.BatchNorm3d(3),
                        nn.Sigmoid())

        self._initialize_weights()
        # print('%s Model Successfully Built \n' % self.gen_name)
    
    def _initialize_weights(self):
        for m in self.modules():
            if isinstance(m, nn.Conv3d):
                nn.init.kaiming_normal_(m.weight, mode='fan_out', nonlinearity='relu')
                if m.bias is not None:
                    nn.init.constant_(m.bias, 0)
            elif isinstance(m, nn.BatchNorm3d):
                nn.init.constant_(m.weight, 1)
                nn.init.constant_(m.bias, 0)
            elif isinstance(m, nn.Linear):
                nn.init.normal_(m.weight, 0, 0.01)
                nn.init.constant_(m.bias, 0)

    def forward(self, app, act):# kp):
        """
        Function to compute a single forward pass through the network, according to the architecture.
        :param app: (tensor) The input appearance encoding for the desired view of the generated video.
                     Must be a tensor of shape: (bsz, in_channels[0], 4, 14, 14) for this application.
        :param rep: (tensor) The input motion representation for the generated video.
                     Must be a tensor of shape: (bsz, in_channels[1], 4, 14, 14) for this application.
        :return: A tensor representing the video generated by the network.
                 Shape of output is: (bsz, 3, out_frames, 112, 112) for this application.
        """

        gru1 = self.conv_gru1(input_tensor=act[0], hidden_state=app[2])
#         print(gru1[0].size())
        gru1 = gru1[0].permute(0,2,1,3,4)
        x = torch.cat([gru1,act[0]],1)
        x = self.upconv1(x)
        x = self.conv1(x)

        gru2 = self.conv_gru2(input_tensor=act[1], hidden_state=app[1])
        gru2 = gru2[0].permute(0,2,1,3,4)
        x = torch.cat([gru2,x],1)
        x = self.upconv2(x)
        x = self.conv2(x)
        
#         print(x.size())
        gru3 = self.conv_gru3(input_tensor=x, hidden_state=app[0])
        gru3 = gru3[0].permute(0,2,1,3,4)
        x = torch.cat([gru3,x],1)
        x = self.conv3(x)
        x = self.upconv3(x)

        x = self.conv4_a(x)
        x = self.conv4_b(x)
#         print(x.size())
        return x

if __name__ == "__main__":
    print_summary = True

    # x = torch.randn(2,330,1,1) 
    model = Generator(out_frames=16)
    print(sum(p.numel() for p in model.parameters() if p.requires_grad))
    #vid = gen(x)
#     print(vid.size())
    
